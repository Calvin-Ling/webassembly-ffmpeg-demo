
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>音视频解码性能对比：原生 Web API vs WASM</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { 
      font-family: system-ui, -apple-system, Roboto, 'Segoe UI', Arial; 
      padding: 20px; 
      max-width: 1200px; 
      margin: 0 auto; 
    }
    .section { 
      margin: 30px 0; 
      padding: 20px; 
      border: 1px solid #ddd; 
      border-radius: 8px; 
      background: #f9f9f9; 
    }
    button { 
      margin: 8px 0; 
      display: block; 
      padding: 10px 20px; 
      background: #007bff; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
    }
    button:hover { background: #0056b3; }
    button:disabled { 
      background: #6c757d; 
      cursor: not-allowed; 
    }
    video, audio { 
      max-width: 100%; 
      margin-top: 12px; 
      border: 1px solid #ccc; 
      border-radius: 4px; 
    }
    .log { 
      background: #f5f5f5; 
      padding: 10px; 
      margin: 10px 0; 
      font-family: monospace; 
      border-radius: 4px; 
      border: 1px solid #ddd; 
      white-space: pre-wrap; 
    }
    .status { 
      padding: 10px; 
      margin: 10px 0; 
      border-radius: 4px; 
    }
    .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    input[type="file"] { 
      margin: 10px 0; 
      padding: 8px; 
      border: 1px solid #ccc; 
      border-radius: 4px; 
    }
    .comparison-result { 
      margin: 15px 0; 
      padding: 15px; 
      border: 1px solid #ddd; 
      border-radius: 6px; 
      background: #fff; 
    }
    .comparison-result h5 { 
      margin: 0 0 10px 0; 
      color: #333; 
    }
    .performance-metrics { 
      background: #f8f9fa; 
      padding: 10px; 
      border-radius: 4px; 
      margin: 10px 0; 
    }
    .api-support-check { 
      padding: 8px; 
      margin: 10px 0; 
      border-radius: 4px; 
      font-size: 14px; 
    }
    .api-support-check.supported { 
      background: #d4edda; 
      color: #155724; 
      border: 1px solid #c3e6cb; 
    }
    .api-support-check.not-supported { 
      background: #f8d7da; 
      color: #721c24; 
      border: 1px solid #f5c6cb; 
    }
  </style>
</head>
<body>
  <h1>音视频解码性能对比</h1>
  <p>原生 Web API (WebCodecs) vs WASM (FFmpeg) 解码性能对比演示</p>


  <div class="section">
    <h2>原生 Web API vs WASM 解码对比</h2>
    <p>使用 AudioDecoder 和 VideoDecoder 原生 API 与 WASM 解码进行性能对比</p>
    <div class="status info">
      <strong>注意：</strong> 原生 WebCodecs API 需要支持 WebCodecs 的现代浏览器（如 Chrome 94+）。如果您的浏览器不支持，将只能使用 WASM 解码。
    </div>
    
    <div class="status info">
      <strong>使用说明：</strong>
      <ul style="margin: 10px 0; padding-left: 20px;">
        <li>选择音频或视频文件进行解码对比</li>
        <li>系统会自动测试原生 Web API 和 WASM 解码性能</li>
        <li>对比结果包括解码时间、文件大小和效率提升百分比</li>
        <li>支持的文件格式：音频(.opus)，视频(.mp4 H.264)</li>
        <li><strong>注意：</strong> 原生 WebCodecs API 对文件格式和编码参数有严格要求</li>
      </ul>
    </div>
    
    <div class="status info">
      <strong>技术说明：</strong> 专门针对 Opus 音频和 H.264 视频优化：
      <ul style="margin: 10px 0; padding-left: 20px;">
        <li><strong>Opus 音频：</strong> 48kHz 采样率，立体声，Ogg 容器格式</li>
        <li><strong>H.264 视频：</strong> Baseline Profile Level 3.0，MP4 容器格式</li>
        <li><strong>原生解码：</strong> 优先使用 WebCodecs API，失败时回退到备选方案</li>
        <li><strong>WASM 解码：</strong> 使用 FFmpeg 进行软件解码</li>
        <li><strong>备选方案：</strong> 音频使用 Web Audio API，视频使用 Canvas 渲染</li>
      </ul>
    </div>
    
    <div class="status info">
      <strong>性能分析：</strong> 为什么 VideoDecoder 比 WASM 解码快？
      <ul style="margin: 10px 0; padding-left: 20px;">
        <li><strong>硬件加速：</strong> VideoDecoder 使用 GPU/专用硬件解码器，WASM 使用 CPU 软件解码</li>
        <li><strong>并行处理：</strong> 硬件解码器支持并行处理，CPU 解码主要是串行处理</li>
        <li><strong>专用优化：</strong> 硬件解码器专门为视频解码优化，CPU 是通用处理器</li>
        <li><strong>内存效率：</strong> 硬件解码器直接在 GPU 内存中处理，减少数据传输</li>
        <li><strong>功耗优势：</strong> 硬件解码功耗更低，发热更少</li>
        <li><strong>典型性能：</strong> 硬件解码通常比软件解码快 3-10 倍</li>
      </ul>
    </div>
    
    <div id="apiSupportCheck" class="api-support-check">
      <div id="audioDecoderSupport"></div>
      <div id="videoDecoderSupport"></div>
    </div>
    
    <h3>音频解码对比 (Opus)</h3>
    <input id="compareAudioFile" type="file" accept=".opus" />
    <button id="compareAudioBtn" disabled onclick="compareAudioDecoding()">开始音频解码对比</button>
    <div id="compareAudioStatus" class="status info" style="display: none;"></div>
    <div id="compareAudioLog" class="log"></div>
    <div id="audioComparisonResults" style="display: none;">
      <h4>对比结果</h4>
      <div id="nativeAudioResult" class="comparison-result"></div>
      <div id="wasmAudioResult" class="comparison-result"></div>
      <div id="audioPerformanceComparison" class="performance-metrics"></div>
    </div>
    
    <h3>视频解码对比 (MP4 H.264)</h3>
    <input id="compareVideoFile" type="file" accept="video/mp4" />
    <button id="compareVideoBtn" disabled onclick="compareVideoDecoding()">开始视频解码对比</button>
    <div id="compareVideoStatus" class="status info" style="display: none;"></div>
    <div id="compareVideoLog" class="log"></div>
    <div id="videoComparisonResults" style="display: none;">
      <h4>对比结果</h4>
      <div id="nativeVideoResult" class="comparison-result"></div>
      <div id="wasmVideoResult" class="comparison-result"></div>
      <div id="videoPerformanceComparison" class="performance-metrics"></div>
    </div>
  </div>

  <script type="module">
    import { ensureFFmpeg, decodeOpusToWavBlob, decodeMp4ToWebmBlob } from '/src/ffmpeg.js';
    
    // 通用函数：获取支持的 MIME 类型
    function getSupportedMimeType() {
      const supportedTypes = [
        'video/webm;codecs=vp8',
        'video/webm;codecs=vp9',
        'video/webm',
        'video/mp4'
      ];
      
      for (const type of supportedTypes) {
        if (MediaRecorder.isTypeSupported(type)) {
          return type;
        }
      }
      return 'video/webm';
    }
    
    // 通用函数：创建 WAV 文件头
    function createWavHeader(sampleRate, channels, dataSize) {
      const buffer = new ArrayBuffer(44);
      const view = new DataView(buffer);
      
      const writeString = (offset, string) => {
        for (let i = 0; i < string.length; i++) {
          view.setUint8(offset + i, string.charCodeAt(i));
        }
      };
      
      writeString(0, 'RIFF');
      view.setUint32(4, 36 + dataSize, true);
      writeString(8, 'WAVE');
      writeString(12, 'fmt ');
      view.setUint32(16, 16, true);
      view.setUint16(20, 1, true);
      view.setUint16(22, channels, true);
      view.setUint32(24, sampleRate, true);
      view.setUint32(28, sampleRate * channels * 2, true);
      view.setUint16(32, channels * 2, true);
      view.setUint16(34, 16, true);
      writeString(36, 'data');
      view.setUint32(40, dataSize, true);
      
      return buffer;
    }
    
    // 原生 Web API 解码功能
    class NativeAudioDecoder {
      constructor() {
        this.decoder = null;
        this.audioData = [];
        this.isDecoding = false;
      }
      
      async decodeAudioFile(file) {
        const startTime = performance.now();
        let pcmConversionTime = 0;
        
        if (!('AudioDecoder' in window)) {
          throw new Error('AudioDecoder API 不支持，请使用支持 WebCodecs 的浏览器');
        }
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          
          // 创建 AudioDecoder
          this.decoder = new AudioDecoder({
            output: (audioData) => {
              this.audioData.push(audioData);
            },
            error: (error) => {
              console.error('AudioDecoder 错误:', error);
              throw error;
            }
          });
          
          // 根据文件类型配置解码器
          const config = await this.getConfigFromFile(file);
          
          await this.decoder.configure(config);
          
          // 对于 Opus 文件，需要从 Ogg 容器中提取 Opus 数据
          const opusData = this.extractOpusFromOgg(arrayBuffer);
          
          // 创建编码数据块
          const encodedChunk = new EncodedAudioChunk({
            type: 'key',
            timestamp: 0,
            data: opusData
          });
          
          // 记录 PCM 转换开始时间
          const pcmStartTime = performance.now();
          
          this.isDecoding = true;
          this.decoder.decode(encodedChunk);
          await this.decoder.flush();
          
          // 记录 PCM 转换结束时间
          pcmConversionTime = performance.now() - pcmStartTime;
          
          // 转换为 WAV 格式
          const wavResult = this.convertToWavBlob();
          
          const endTime = performance.now();
          const totalDuration = endTime - startTime;
          
          return {
            blob: wavResult,
            duration: totalDuration,
            pcmConversionTime: pcmConversionTime,
            size: wavResult.size
          };
        } catch (error) {
          // 如果 WebCodecs 解码失败，尝试使用 Web Audio API 作为备选方案
          console.warn('WebCodecs AudioDecoder 失败，尝试使用 Web Audio API:', error.message);
          return this.decodeWithWebAudioAPI(file);
        }
      }
      
      async decodeWithWebAudioAPI(file) {
        const startTime = performance.now();
        let pcmConversionTime = 0;
        
        // 使用 Web Audio API 作为备选方案
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          
          // 记录 PCM 转换开始时间
          const pcmStartTime = performance.now();
          
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          
          // 记录 PCM 转换结束时间
          pcmConversionTime = performance.now() - pcmStartTime;
          
          // 转换为 WAV 格式
          const wavBlob = this.audioBufferToWav(audioBuffer);
          
          const endTime = performance.now();
          const totalDuration = endTime - startTime;
          
          return {
            blob: wavBlob,
            duration: totalDuration,
            pcmConversionTime: pcmConversionTime,
            size: wavBlob.size
          };
        } catch (error) {
          const endTime = performance.now();
          const totalDuration = endTime - startTime;
          throw new Error(`音频解码失败: ${error.message} (总耗时: ${totalDuration.toFixed(2)}ms, PCM转换: ${pcmConversionTime.toFixed(2)}ms)`);
        }
      }
      
      audioBufferToWav(audioBuffer) {
        const numberOfChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const length = audioBuffer.length;
        
        // 创建 WAV 文件
        const dataSize = length * numberOfChannels * 2;
        const wavHeader = createWavHeader(sampleRate, numberOfChannels, dataSize);
        const buffer = new ArrayBuffer(wavHeader.byteLength + dataSize);
        new Uint8Array(buffer, 0, wavHeader.byteLength).set(new Uint8Array(wavHeader));
        
        // 复制音频数据
        const wavData = new Int16Array(buffer, 44);
        let offset = 0;
        
        for (let i = 0; i < length; i++) {
          for (let channel = 0; channel < numberOfChannels; channel++) {
            const sample = audioBuffer.getChannelData(channel)[i];
            wavData[offset] = Math.max(-32768, Math.min(32767, sample * 32768));
            offset++;
          }
        }
        
        return new Blob([buffer], { type: 'audio/wav' });
      }
      
      async getConfigFromFile(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        
        // 只支持 Opus 格式
        if (extension === 'opus') {
          return { 
            codec: 'opus',
            sampleRate: 48000,
            numberOfChannels: 2,
            // Opus 特定的配置参数
            description: new Uint8Array([
              0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64, // "OpusHead"
              0x01, 0x02, 0x38, 0x01, 0x80, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x00
            ])
          };
        }
        
        throw new Error(`不支持的音频格式: ${extension}。只支持 .opus 格式`);
      }
      
      isOpusFile(data) {
        // 检查 Ogg Opus 文件头
        return data.length >= 4 && 
               data[0] === 0x4F && data[1] === 0x67 && 
               data[2] === 0x67 && data[3] === 0x53;
      }
      
      extractOpusFromOgg(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        const opusPackets = [];
        
        let offset = 0;
        while (offset < data.length - 27) {
          // 检查 Ogg 页面头
          if (data[offset] === 0x4F && data[offset + 1] === 0x67 && 
              data[offset + 2] === 0x67 && data[offset + 3] === 0x53) {
            
            // 读取页面段数
            const pageSegments = data[offset + 26];
            const segmentTableOffset = offset + 27;
            
            // 计算页面数据大小
            let pageDataSize = 0;
            for (let i = 0; i < pageSegments; i++) {
              pageDataSize += data[segmentTableOffset + i];
            }
            
            // 提取 Opus 数据
            const pageDataOffset = segmentTableOffset + pageSegments;
            const pageData = data.slice(pageDataOffset, pageDataOffset + pageDataSize);
            
            // 检查是否是 Opus 识别头或注释头，跳过这些
            if (pageData.length > 8) {
              const headerType = pageData[0];
              if (headerType === 0x4F && pageData[1] === 0x70 && 
                  pageData[2] === 0x75 && pageData[3] === 0x73) {
                // 这是 Opus 识别头，跳过
                offset = pageDataOffset + pageDataSize;
                continue;
              }
            }
            
            // 添加 Opus 数据包
            if (pageData.length > 0) {
              opusPackets.push(pageData);
            }
            
            offset = pageDataOffset + pageDataSize;
          } else {
            offset++;
          }
        }
        
        // 合并所有 Opus 数据包
        const totalSize = opusPackets.reduce((sum, packet) => sum + packet.length, 0);
        const result = new Uint8Array(totalSize);
        let writeOffset = 0;
        
        for (const packet of opusPackets) {
          result.set(packet, writeOffset);
          writeOffset += packet.length;
        }
        
        return result.buffer;
      }
      
      
      convertToWavBlob() {
        if (this.audioData.length === 0) {
          throw new Error('没有音频数据');
        }
        
        // 简化的 WAV 转换 - 实际应用中需要更复杂的处理
        const audioData = this.audioData[0];
        const sampleRate = audioData.sampleRate;
        const numberOfChannels = audioData.numberOfChannels;
        const numberOfFrames = audioData.numberOfFrames;
        
        // 创建音频缓冲区
        const audioBuffer = audioData.copyTo();
        const audioView = new Float32Array(audioBuffer);
        
        // 转换为 16-bit PCM
        const pcmData = new Int16Array(numberOfFrames * numberOfChannels);
        for (let i = 0; i < audioView.length; i++) {
          pcmData[i] = Math.max(-32768, Math.min(32767, audioView[i] * 32768));
        }
        
        const dataSize = pcmData.length * 2; // 16-bit = 2 bytes per sample
        const wavHeader = createWavHeader(sampleRate, numberOfChannels, dataSize);
        const buffer = new ArrayBuffer(wavHeader.byteLength + dataSize);
        new Uint8Array(buffer, 0, wavHeader.byteLength).set(new Uint8Array(wavHeader));
        
        // 复制 PCM 数据
        const wavView = new Int16Array(buffer, 44);
        wavView.set(pcmData);
        
        return new Blob([buffer], { type: 'audio/wav' });
      }
    }
    
    class NativeVideoDecoder {
      constructor() {
        this.decoder = null;
        this.videoFrames = [];
        this.isDecoding = false;
      }
      
      async decodeVideoFile(file) {
        const startTime = performance.now();
        let rgbaConversionTime = 0;
        
        if (!('VideoDecoder' in window)) {
          throw new Error('VideoDecoder API 不支持，请使用支持 WebCodecs 的浏览器');
        }
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          
          // 创建 VideoDecoder
          this.decoder = new VideoDecoder({
            output: (frame) => {
              this.videoFrames.push(frame);
            },
            error: (error) => {
              console.error('VideoDecoder 错误:', error);
              throw error;
            }
          });
          
          // 配置解码器
          const config = await this.getConfigFromFile(file);
          
          await this.decoder.configure(config);
          
          // 从 MP4 文件中提取 H.264 数据
          const h264Data = this.extractH264FromMP4(arrayBuffer);
          // 尝试解码多个数据包
          this.isDecoding = true;
          
          // 将 H.264 数据分割成多个数据包
          const h264Array = new Uint8Array(h264Data);
          const packets = this.splitH264IntoPackets(h264Array);
          
          // 记录 RGBA 转换开始时间
          const rgbaStartTime = performance.now();
          
          for (let i = 0; i < packets.length; i++) {
            const packet = packets[i];
            const encodedChunk = new EncodedVideoChunk({
              type: i === 0 ? 'key' : 'delta', // 第一帧是关键帧
              timestamp: i * 33333, // 30 FPS = 33.33ms per frame
              duration: 33333,
              data: packet
            });
            
            this.decoder.decode(encodedChunk);
          }
          
          await this.decoder.flush();
          
          // 记录 RGBA 转换结束时间
          rgbaConversionTime = performance.now() - rgbaStartTime;
          
          // 如果没有解码出帧，尝试使用 Canvas 备选方案
          if (this.videoFrames.length === 0) {
            console.log('原生解码: 没有解码出帧，使用 Canvas 备选方案');
            return this.decodeWithCanvas(file);
          }
          
          // 转换为 WebM 格式
          const webmResult = this.convertToWebmBlob();
          
          const endTime = performance.now();
          const totalDuration = endTime - startTime;
          
          return {
            blob: webmResult,
            duration: totalDuration,
            rgbaConversionTime: rgbaConversionTime,
            size: webmResult.size
          };
        } catch (error) {
          // 如果 WebCodecs 解码失败，尝试使用 Canvas 作为备选方案
          console.warn('WebCodecs VideoDecoder 失败，尝试使用 Canvas 备选方案:', error.message);
          return this.decodeWithCanvas(file);
        }
      }
      
      async decodeWithCanvas(file) {
        const startTime = performance.now();
        let rgbaConversionTime = 0;
        
        // 使用 Canvas 作为备选方案
        const video = document.createElement('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            
            // 创建 MediaStream
            const stream = canvas.captureStream(30); // 30 FPS
            
            const mimeType = getSupportedMimeType();
            
            
            const mediaRecorder = new MediaRecorder(stream, {
              mimeType: mimeType
            });
            
            const chunks = [];
            mediaRecorder.ondataavailable = (event) => {
              if (event.data.size > 0) {
                chunks.push(event.data);
              }
            };
            
            mediaRecorder.onstop = () => {
              const webmBlob = new Blob(chunks, { type: mimeType });
              
              const endTime = performance.now();
              const totalDuration = endTime - startTime;
              
              resolve({
                blob: webmBlob,
                duration: totalDuration,
                rgbaConversionTime: rgbaConversionTime,
                size: webmBlob.size
              });
            };
            
            mediaRecorder.onerror = (error) => {
              console.error('Canvas 备选方案: MediaRecorder 错误:', error);
              reject(new Error(`MediaRecorder 错误: ${error.message}`));
            };
            
            // 开始录制
            mediaRecorder.start(100);
            
            // 播放视频并录制
            video.oncanplay = () => {
              
              const videoDuration = 5000; // 5秒
              const frameRate = 30; // 30 FPS
              const totalFrames = Math.floor((videoDuration / 1000) * frameRate); // 150帧
              const frameInterval = 1000 / frameRate; // 33.33ms per frame
              
              let currentFrame = 0;
              
              const drawFrame = () => {
                if (currentFrame < totalFrames) {
                  // 绘制视频帧到 Canvas
                  ctx.drawImage(video, 0, 0);
                  currentFrame++;
                  setTimeout(drawFrame, frameInterval);
                } else {
                  // 录制完成
                  setTimeout(() => {
                    mediaRecorder.stop();
                  }, 200);
                }
              };
              
              // 开始绘制帧
              drawFrame();
            };
            
            video.play();
          };
          
          video.onerror = (error) => {
            console.error('Canvas 备选方案: 视频加载失败:', error);
            reject(new Error('视频加载失败'));
          };
          
          video.src = URL.createObjectURL(file);
        });
      }
      
      async getConfigFromFile(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        
        // 只支持 MP4 (H.264) 格式
        if (extension === 'mp4') {
          return this.getH264Config();
        }
        
        throw new Error(`不支持的视频格式: ${extension}。只支持 .mp4 (H.264) 格式`);
      }
      
      isMP4File(data) {
        // 检查 MP4 文件头
        return data.length >= 8 && 
               data[4] === 0x66 && data[5] === 0x74 && 
               data[6] === 0x79 && data[7] === 0x70;
      }
      
      getH264Config() {
        // H.264 配置 - 针对常见的 MP4 视频
        return {
          codec: 'avc1.42E01E', // H.264 Baseline Profile, Level 3.0
          codedWidth: 1920,
          codedHeight: 1080,
          displayAspectWidth: 1920,
          displayAspectHeight: 1080,
          // 标准的 avcC (AVC Configuration) 数据
          description: new Uint8Array([
            // avcC 头部
            0x01, 0x42, 0xE0, 0x1E, // configurationVersion, AVCProfileIndication, profile_compatibility, AVCLevelIndication
            0xFF, // lengthSizeMinusOne (3)
            0xE1, // numOfSequenceParameterSets (1)
            0x00, 0x1A, // sequenceParameterSetLength (26)
            // SPS (Sequence Parameter Set)
            0x67, 0x42, 0xE0, 0x1E, 0xAB, 0x40, 0x50, 0x05, 
            0xBB, 0x01, 0x10, 0x00, 0x00, 0x03, 0x00, 0x10, 
            0x00, 0x00, 0x03, 0x03, 0xC0, 0xF1, 0x42, 0x99, 0x60,
            0x00, // numOfPictureParameterSets (0)
            // PPS (Picture Parameter Set) - 可选
            0x00, 0x00, 0x00, 0x00
          ])
        };
      }
      
      extractH264FromMP4(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        const h264Frames = [];
        
        
        // 简化的 MP4 解析，查找 H.264 数据
        let offset = 0;
        while (offset < data.length - 8) {
          // 查找 NAL 单元起始码 (0x00 0x00 0x00 0x01 或 0x00 0x00 0x01)
          if ((data[offset] === 0x00 && data[offset + 1] === 0x00 && 
               data[offset + 2] === 0x00 && data[offset + 3] === 0x01) ||
              (data[offset] === 0x00 && data[offset + 1] === 0x00 && 
               data[offset + 2] === 0x01)) {
            
            const startCodeLength = (data[offset + 2] === 0x01) ? 3 : 4;
            let frameStart = offset + startCodeLength;
            
            // 查找下一个起始码
            let frameEnd = frameStart;
            while (frameEnd < data.length - 4) {
              if ((data[frameEnd] === 0x00 && data[frameEnd + 1] === 0x00 && 
                   data[frameEnd + 2] === 0x00 && data[frameEnd + 3] === 0x01) ||
                  (data[frameEnd] === 0x00 && data[frameEnd + 1] === 0x00 && 
                   data[frameEnd + 2] === 0x01)) {
                break;
              }
              frameEnd++;
            }
            
            // 提取 H.264 帧数据
            const frameData = data.slice(frameStart, frameEnd);
            if (frameData.length > 0) {
              h264Frames.push(frameData);
            }
            
            offset = frameEnd;
          } else {
            offset++;
          }
        }
        
        
        // 合并所有 H.264 帧数据
        const totalSize = h264Frames.reduce((sum, frame) => sum + frame.length, 0);
        const result = new Uint8Array(totalSize);
        let writeOffset = 0;
        
        for (const frame of h264Frames) {
          result.set(frame, writeOffset);
          writeOffset += frame.length;
        }
        
        return result.buffer;
      }
      
      splitH264IntoPackets(h264Data) {
        const packets = [];
        let offset = 0;
        
        while (offset < h264Data.length - 4) {
          // 查找 NAL 单元起始码
          if ((h264Data[offset] === 0x00 && h264Data[offset + 1] === 0x00 && 
               h264Data[offset + 2] === 0x00 && h264Data[offset + 3] === 0x01) ||
              (h264Data[offset] === 0x00 && h264Data[offset + 1] === 0x00 && 
               h264Data[offset + 2] === 0x01)) {
            
            const startCodeLength = (h264Data[offset + 2] === 0x01) ? 3 : 4;
            let packetStart = offset + startCodeLength;
            
            // 查找下一个起始码
            let packetEnd = packetStart;
            while (packetEnd < h264Data.length - 4) {
              if ((h264Data[packetEnd] === 0x00 && h264Data[packetEnd + 1] === 0x00 && 
                   h264Data[packetEnd + 2] === 0x00 && h264Data[packetEnd + 3] === 0x01) ||
                  (h264Data[packetEnd] === 0x00 && h264Data[packetEnd + 1] === 0x00 && 
                   h264Data[packetEnd + 2] === 0x01)) {
                break;
              }
              packetEnd++;
            }
            
            // 提取数据包
            const packetData = h264Data.slice(packetStart, packetEnd);
            if (packetData.length > 0) {
              packets.push(packetData.buffer);
            }
            
            offset = packetEnd;
          } else {
            offset++;
          }
        }
        
        return packets;
      }
      
      
      async convertToWebmBlob() {
        if (this.videoFrames.length === 0) {
          throw new Error('没有视频帧数据');
        }
        
        // 使用 MediaRecorder API 生成真正的 WebM 文件
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const frame = this.videoFrames[0];
        
        canvas.width = frame.displayWidth;
        canvas.height = frame.displayHeight;
        
        
        // 创建 MediaStream
        const stream = canvas.captureStream(30); // 30 FPS
        
        const mimeType = getSupportedMimeType();
        
        
        // 使用 MediaRecorder 录制为 WebM
        const mediaRecorder = new MediaRecorder(stream, {
          mimeType: mimeType
        });
        
        const chunks = [];
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            chunks.push(event.data);
          }
        };
        
        return new Promise((resolve, reject) => {
          mediaRecorder.onstop = () => {
            const webmBlob = new Blob(chunks, { type: mimeType });
            resolve(webmBlob);
          };
          
          mediaRecorder.onerror = (error) => {
            console.error('MediaRecorder 错误:', error);
            reject(new Error(`MediaRecorder 错误: ${error.message}`));
          };
          
          // 开始录制
          mediaRecorder.start(100); // 每100ms生成一个数据块
          
          // 绘制所有帧并录制
          let frameIndex = 0;
          const frameDuration = 1000 / 30; // 30 FPS = 33.33ms per frame
          
          const drawFrame = () => {
            if (frameIndex < this.videoFrames.length) {
              const currentFrame = this.videoFrames[frameIndex];
              ctx.drawImage(currentFrame, 0, 0);
              frameIndex++;
              
              // 使用 setTimeout 而不是 requestAnimationFrame 来控制帧率
              setTimeout(drawFrame, frameDuration);
            } else {
            // 如果只有一帧，重复播放创建短视频
            if (this.videoFrames.length === 1) {
              const videoDuration = 5000; // 5秒
              const totalFrames = Math.floor((videoDuration / 1000) * 30); // 150帧
                let repeatFrame = 0;
                
                const repeatFrameFunc = () => {
                  if (repeatFrame < totalFrames) {
                    ctx.drawImage(this.videoFrames[0], 0, 0);
                    repeatFrame++;
                    setTimeout(repeatFrameFunc, frameDuration);
                  } else {
                    setTimeout(() => {
                      mediaRecorder.stop();
                    }, 200);
                  }
                };
                
                repeatFrameFunc();
              } else {
                // 录制完成，等待一段时间确保所有数据都被录制
                setTimeout(() => {
                  mediaRecorder.stop();
                }, 500); // 给更多时间让最后一帧被录制
              }
            }
          };
          
          // 开始绘制第一帧
          drawFrame();
        });
      }
    }
    
    // 性能对比功能
    window.compareAudioDecoding = async function() {
      const fileInput = document.getElementById('compareAudioFile');
      const statusEl = document.getElementById('compareAudioStatus');
      const logEl = document.getElementById('compareAudioLog');
      const resultsEl = document.getElementById('audioComparisonResults');
      
      if (!fileInput.files[0]) {
        statusEl.className = 'status error';
        statusEl.textContent = '请先选择一个音频文件';
        statusEl.style.display = 'block';
        return;
      }
      
      const file = fileInput.files[0];
      const results = {
        native: null,
        wasm: null
      };
      
      try {
        statusEl.className = 'status info';
        statusEl.textContent = '正在进行音频解码对比...';
        statusEl.style.display = 'block';
        logEl.textContent = '开始音频解码性能对比...\n\n';
        
        // 测试原生 AudioDecoder
        logEl.textContent += '1. 测试原生 AudioDecoder API...\n';
        try {
          const nativeDecoder = new NativeAudioDecoder();
          const nativeResult = await nativeDecoder.decodeAudioFile(file);
          results.native = {
            blob: nativeResult.blob,
            time: nativeResult.duration,
            pcmTime: nativeResult.pcmConversionTime,
            size: nativeResult.size
          };
          logEl.textContent += `   ✓ 原生解码完成，总耗时: ${results.native.time.toFixed(2)}ms (PCM转换: ${results.native.pcmTime?.toFixed(2) || 'N/A'}ms)\n`;
        } catch (error) {
          logEl.textContent += `   ✗ 原生解码失败: ${error.message}\n`;
          results.native = { error: error.message };
        }
        
        // 测试 WASM 解码
        logEl.textContent += '\n2. 测试 WASM (FFmpeg) 解码 + MediaRecorder 编码...\n';
        try {
          const wasmResult = await decodeOpusToWavBlob(file);
          results.wasm = {
            blob: wasmResult.blob,
            time: wasmResult.duration,
            pcmTime: wasmResult.pcmConversionTime,
            size: wasmResult.size
          };
          logEl.textContent += `   ✓ WASM解码完成，总耗时: ${results.wasm.time.toFixed(2)}ms (PCM转换: ${results.wasm.pcmTime?.toFixed(2) || 'N/A'}ms)\n`;
        } catch (error) {
          logEl.textContent += `   ✗ WASM解码失败: ${error.message}\n`;
          results.wasm = { error: error.message };
        }
        
        // 显示对比结果
        displayAudioComparisonResults(results);
        resultsEl.style.display = 'block';
        
        statusEl.className = 'status success';
        statusEl.textContent = '音频解码对比完成！';
        
      } catch (error) {
        statusEl.className = 'status error';
        statusEl.textContent = '对比过程中发生错误';
        logEl.textContent += `\n对比失败: ${error.message}`;
        console.error('音频对比错误:', error);
      }
    };
    
    window.compareVideoDecoding = async function() {
      const fileInput = document.getElementById('compareVideoFile');
      const statusEl = document.getElementById('compareVideoStatus');
      const logEl = document.getElementById('compareVideoLog');
      const resultsEl = document.getElementById('videoComparisonResults');
      
      if (!fileInput.files[0]) {
        statusEl.className = 'status error';
        statusEl.textContent = '请先选择一个视频文件';
        statusEl.style.display = 'block';
        return;
      }
      
      const file = fileInput.files[0];
      const results = {
        native: null,
        wasm: null
      };
      
      try {
        statusEl.className = 'status info';
        statusEl.textContent = '正在进行视频解码对比...';
        statusEl.style.display = 'block';
        logEl.textContent = '开始视频解码性能对比（生成有效 WebM 文件）...\n\n';
        
        // 测试原生 VideoDecoder
        logEl.textContent += '1. 测试原生 VideoDecoder API + MediaRecorder 编码...\n';
        try {
          const nativeDecoder = new NativeVideoDecoder();
          const nativeResult = await nativeDecoder.decodeVideoFile(file);
          results.native = {
            blob: nativeResult.blob,
            time: nativeResult.duration,
            rgbaTime: nativeResult.rgbaConversionTime,
            size: nativeResult.size
          };
          logEl.textContent += `   ✓ 原生解码完成，总耗时: ${results.native.time.toFixed(2)}ms (RGBA转换: ${results.native.rgbaTime?.toFixed(2) || 'N/A'}ms)\n`;
        } catch (error) {
          logEl.textContent += `   ✗ 原生解码失败: ${error.message}\n`;
          results.native = { error: error.message };
        }
        
        // 测试 WASM 解码
        logEl.textContent += '\n2. 测试 WASM (FFmpeg) 解码 + MediaRecorder 编码...\n';
        try {
          const wasmResult = await decodeMp4ToWebmBlob(file);
          results.wasm = {
            blob: wasmResult.blob,
            time: wasmResult.duration,
            rgbaTime: wasmResult.rgbaConversionTime,
            size: wasmResult.size
          };
          logEl.textContent += `   ✓ WASM解码完成，总耗时: ${results.wasm.time.toFixed(2)}ms (RGBA转换: ${results.wasm.rgbaTime?.toFixed(2) || 'N/A'}ms)\n`;
        } catch (error) {
          logEl.textContent += `   ✗ WASM解码失败: ${error.message}\n`;
          results.wasm = { error: error.message };
        }
        
        // 显示对比结果
        displayVideoComparisonResults(results);
        resultsEl.style.display = 'block';
        
        statusEl.className = 'status success';
        statusEl.textContent = '视频解码对比完成！';
        
      } catch (error) {
        statusEl.className = 'status error';
        statusEl.textContent = '对比过程中发生错误';
        logEl.textContent += `\n对比失败: ${error.message}`;
        console.error('视频对比错误:', error);
      }
    };
    
    function displayAudioComparisonResults(results) {
      const nativeResultEl = document.getElementById('nativeAudioResult');
      const wasmResultEl = document.getElementById('wasmAudioResult');
      const comparisonEl = document.getElementById('audioPerformanceComparison');
      
      // 原生结果
      if (results.native && !results.native.error) {
        nativeResultEl.innerHTML = `
          <h5>原生 AudioDecoder 结果</h5>
          <p>总耗时: ${results.native.time.toFixed(2)}ms</p>
          <p>PCM转换: ${results.native.pcmTime?.toFixed(2) || 'N/A'}ms</p>
          <p>输出大小: ${results.native.size} bytes</p>
          <audio controls src="${URL.createObjectURL(results.native.blob)}"></audio>
        `;
      } else {
        nativeResultEl.innerHTML = `
          <h5>原生 AudioDecoder 结果</h5>
          <p style="color: red;">解码失败: ${results.native?.error || '未知错误'}</p>
          <p style="color: gray; font-size: 12px;">WebCodecs API 对文件格式要求严格，可能需要特定的编码参数</p>
        `;
      }
      
      // WASM结果
      if (results.wasm && !results.wasm.error) {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p>总耗时: ${results.wasm.time.toFixed(2)}ms</p>
          <p>PCM转换: ${results.wasm.pcmTime?.toFixed(2) || 'N/A'}ms</p>
          <p>输出大小: ${results.wasm.size} bytes</p>
          <audio controls src="${URL.createObjectURL(results.wasm.blob)}"></audio>
        `;
      } else {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p style="color: red;">解码失败: ${results.wasm?.error || '未知错误'}</p>
        `;
      }
      
      // 性能对比
      if (results.native && results.wasm && !results.native.error && !results.wasm.error) {
        const speedRatio = results.wasm.time / results.native.time;
        const fasterMethod = results.native.time < results.wasm.time ? '原生 AudioDecoder' : 'WASM (FFmpeg)';
        const speedDifference = Math.abs(results.native.time - results.wasm.time);
        const efficiency = results.native.time < results.wasm.time ? 
          `原生解码比 WASM 快 ${((results.wasm.time / results.native.time - 1) * 100).toFixed(1)}%` :
          `WASM 解码比原生快 ${((results.native.time / results.wasm.time - 1) * 100).toFixed(1)}%`;
        
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p><strong>速度对比:</strong> ${fasterMethod} 更快</p>
          <p><strong>时间差:</strong> ${speedDifference.toFixed(2)}ms</p>
          <p><strong>速度比:</strong> ${speedRatio.toFixed(2)}x</p>
          <p><strong>效率提升:</strong> ${efficiency}</p>
          <p><strong>大小对比:</strong> 原生 ${results.native.size} bytes vs WASM ${results.wasm.size} bytes</p>
        `;
      } else {
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p style="color: orange;">无法进行完整对比，部分解码失败</p>
        `;
      }
    }
    
    function displayVideoComparisonResults(results) {
      const nativeResultEl = document.getElementById('nativeVideoResult');
      const wasmResultEl = document.getElementById('wasmVideoResult');
      const comparisonEl = document.getElementById('videoPerformanceComparison');
      
      // 原生结果
      if (results.native && !results.native.error) {
        nativeResultEl.innerHTML = `
          <h5>原生 VideoDecoder + MediaRecorder 结果</h5>
          <p>总耗时: ${results.native.time.toFixed(2)}ms</p>
          <p>RGBA转换: ${results.native.rgbaTime?.toFixed(2) || 'N/A'}ms</p>
          <p>WebM 文件大小: ${results.native.size} bytes</p>
          <video controls src="${URL.createObjectURL(results.native.blob)}"></video>
        `;
      } else {
        nativeResultEl.innerHTML = `
          <h5>原生 VideoDecoder 结果</h5>
          <p style="color: red;">解码失败: ${results.native?.error || '未知错误'}</p>
          <p style="color: gray; font-size: 12px;">WebCodecs API 对文件格式要求严格，可能需要特定的编码参数</p>
        `;
      }
      
      // WASM结果
      if (results.wasm && !results.wasm.error) {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) + MediaRecorder 结果</h5>
          <p>总耗时: ${results.wasm.time.toFixed(2)}ms</p>
          <p>RGBA转换: ${results.wasm.rgbaTime?.toFixed(2) || 'N/A'}ms</p>
          <p>WebM 文件大小: ${results.wasm.size} bytes</p>
          <video controls src="${URL.createObjectURL(results.wasm.blob)}"></video>
        `;
      } else {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p style="color: red;">解码失败: ${results.wasm?.error || '未知错误'}</p>
        `;
      }
      
      // 性能对比
      if (results.native && results.wasm && !results.native.error && !results.wasm.error) {
        const speedRatio = results.wasm.time / results.native.time;
        const fasterMethod = results.native.time < results.wasm.time ? '原生 VideoDecoder + MediaRecorder' : 'WASM (FFmpeg) + MediaRecorder';
        const speedDifference = Math.abs(results.native.time - results.wasm.time);
        const efficiency = results.native.time < results.wasm.time ? 
          `原生解码+编码比 WASM 快 ${((results.wasm.time / results.native.time - 1) * 100).toFixed(1)}%` :
          `WASM 解码+编码比原生快 ${((results.native.time / results.wasm.time - 1) * 100).toFixed(1)}%`;
        
        comparisonEl.innerHTML = `
          <h5>性能对比（生成有效 WebM 文件）</h5>
          <p><strong>总处理时间:</strong> ${fasterMethod} 更快</p>
          <p><strong>时间差:</strong> ${speedDifference.toFixed(2)}ms</p>
          <p><strong>速度比:</strong> ${speedRatio.toFixed(2)}x</p>
          <p><strong>效率提升:</strong> ${efficiency}</p>
          <p><strong>WebM 文件大小:</strong> 原生 ${results.native.size} bytes vs WASM ${results.wasm.size} bytes</p>
          <p><small><strong>注:</strong> 两种方法都使用 MediaRecorder API 进行最终编码，确保生成可播放的 WebM 文件。</small></p>
        `;
      } else {
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p style="color: orange;">无法进行完整对比，部分解码失败</p>
        `;
      }
    }
    
    // 检查 Web API 支持
    function checkAPISupport() {
      const audioSupportEl = document.getElementById('audioDecoderSupport');
      const videoSupportEl = document.getElementById('videoDecoderSupport');
      
      // 检查 AudioDecoder 支持
      if ('AudioDecoder' in window) {
        audioSupportEl.className = 'api-support-check supported';
        audioSupportEl.textContent = '✓ AudioDecoder API 支持';
      } else {
        audioSupportEl.className = 'api-support-check not-supported';
        audioSupportEl.textContent = '✗ AudioDecoder API 不支持 (需要支持 WebCodecs 的浏览器)';
      }
      
      // 检查 VideoDecoder 支持
      if ('VideoDecoder' in window) {
        videoSupportEl.className = 'api-support-check supported';
        videoSupportEl.textContent = '✓ VideoDecoder API 支持';
      } else {
        videoSupportEl.className = 'api-support-check not-supported';
        videoSupportEl.textContent = '✗ VideoDecoder API 不支持 (需要支持 WebCodecs 的浏览器)';
      }
    }
    
    // 初始化事件监听器
    function initializeEventListeners() {
      // 音频文件选择
      const audioFileInput = document.getElementById('compareAudioFile');
      const audioBtn = document.getElementById('compareAudioBtn');
      
      audioFileInput.addEventListener('change', function() {
        audioBtn.disabled = !this.files[0];
      });
      
      // 视频文件选择
      const videoFileInput = document.getElementById('compareVideoFile');
      const videoBtn = document.getElementById('compareVideoBtn');
      
      videoFileInput.addEventListener('change', function() {
        videoBtn.disabled = !this.files[0];
      });
    }
    
    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', function() {
      checkAPISupport();
      initializeEventListeners();
    });
    
  </script>
</body>
</html>
