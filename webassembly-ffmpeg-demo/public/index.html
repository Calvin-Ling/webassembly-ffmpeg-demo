
<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <title>音视频解码性能对比：原生 Web API vs WASM</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { 
      font-family: system-ui, -apple-system, Roboto, 'Segoe UI', Arial; 
      padding: 20px; 
      max-width: 1200px; 
      margin: 0 auto; 
    }
    .section { 
      margin: 30px 0; 
      padding: 20px; 
      border: 1px solid #ddd; 
      border-radius: 8px; 
      background: #f9f9f9; 
    }
    button { 
      margin: 8px 0; 
      display: block; 
      padding: 10px 20px; 
      background: #007bff; 
      color: white; 
      border: none; 
      border-radius: 4px; 
      cursor: pointer; 
    }
    button:hover { background: #0056b3; }
    button:disabled { 
      background: #6c757d; 
      cursor: not-allowed; 
    }
    video, audio { 
      max-width: 100%; 
      margin-top: 12px; 
      border: 1px solid #ccc; 
      border-radius: 4px; 
    }
    .log { 
      background: #f5f5f5; 
      padding: 10px; 
      margin: 10px 0; 
      font-family: monospace; 
      border-radius: 4px; 
      border: 1px solid #ddd; 
      white-space: pre-wrap; 
    }
    .status { 
      padding: 10px; 
      margin: 10px 0; 
      border-radius: 4px; 
    }
    .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
    .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
    .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    input[type="file"] { 
      margin: 10px 0; 
      padding: 8px; 
      border: 1px solid #ccc; 
      border-radius: 4px; 
    }
    .comparison-result { 
      margin: 15px 0; 
      padding: 15px; 
      border: 1px solid #ddd; 
      border-radius: 6px; 
      background: #fff; 
    }
    .comparison-result h5 { 
      margin: 0 0 10px 0; 
      color: #333; 
    }
    .performance-metrics { 
      background: #f8f9fa; 
      padding: 10px; 
      border-radius: 4px; 
      margin: 10px 0; 
    }
    .api-support-check { 
      padding: 8px; 
      margin: 10px 0; 
      border-radius: 4px; 
      font-size: 14px; 
    }
    .api-support-check.supported { 
      background: #d4edda; 
      color: #155724; 
      border: 1px solid #c3e6cb; 
    }
    .api-support-check.not-supported { 
      background: #f8d7da; 
      color: #721c24; 
      border: 1px solid #f5c6cb; 
    }
  </style>
</head>
<body>
  <h1>音视频解码性能对比</h1>
  <p>原生 Web API (WebCodecs) vs WASM (FFmpeg) 解码性能对比演示</p>


  <div class="section">
    <h2>原生 Web API vs WASM 解码对比</h2>
    <p>使用 AudioDecoder 和 VideoDecoder 原生 API 与 WASM 解码进行性能对比</p>
    <div class="status info">
      <strong>注意：</strong> 原生 WebCodecs API 需要支持 WebCodecs 的现代浏览器（如 Chrome 94+）。如果您的浏览器不支持，将只能使用 WASM 解码。
    </div>
    
    <div class="status info">
      <strong>使用说明：</strong>
      <ul style="margin: 10px 0; padding-left: 20px;">
        <li>选择音频或视频文件进行解码对比</li>
        <li>系统会自动测试原生 Web API 和 WASM 解码性能</li>
        <li>对比结果包括解码时间、文件大小和效率提升百分比</li>
        <li>支持的文件格式：音频(.opus)，视频(.mp4 H.264)</li>
        <li><strong>注意：</strong> 原生 WebCodecs API 对文件格式和编码参数有严格要求</li>
      </ul>
    </div>
    
    <div class="status info">
      <strong>技术说明：</strong> 专门针对 Opus 音频和 H.264 视频优化：
      <ul style="margin: 10px 0; padding-left: 20px;">
        <li><strong>Opus 音频：</strong> 48kHz 采样率，立体声，Ogg 容器格式</li>
        <li><strong>H.264 视频：</strong> Baseline Profile Level 3.0，MP4 容器格式</li>
        <li><strong>原生解码：</strong> 优先使用 WebCodecs API，失败时回退到备选方案</li>
        <li><strong>WASM 解码：</strong> 使用 FFmpeg 进行软件解码</li>
        <li><strong>备选方案：</strong> 音频使用 Web Audio API，视频使用 Canvas 渲染</li>
      </ul>
    </div>
    
    <div class="status info">
      <strong>性能分析：</strong> 为什么 VideoDecoder 比 WASM 解码快？
      <ul style="margin: 10px 0; padding-left: 20px;">
        <li><strong>硬件加速：</strong> VideoDecoder 使用 GPU/专用硬件解码器，WASM 使用 CPU 软件解码</li>
        <li><strong>并行处理：</strong> 硬件解码器支持并行处理，CPU 解码主要是串行处理</li>
        <li><strong>专用优化：</strong> 硬件解码器专门为视频解码优化，CPU 是通用处理器</li>
        <li><strong>内存效率：</strong> 硬件解码器直接在 GPU 内存中处理，减少数据传输</li>
        <li><strong>功耗优势：</strong> 硬件解码功耗更低，发热更少</li>
        <li><strong>典型性能：</strong> 硬件解码通常比软件解码快 3-10 倍</li>
      </ul>
    </div>
    
    <div id="apiSupportCheck" class="api-support-check">
      <div id="audioDecoderSupport"></div>
      <div id="videoDecoderSupport"></div>
    </div>
    
    <h3>音频解码对比 (Opus)</h3>
    <input id="compareAudioFile" type="file" accept=".opus" />
    <button id="compareAudioBtn" disabled onclick="compareAudioDecoding()">开始音频解码对比</button>
    <div id="compareAudioStatus" class="status info" style="display: none;"></div>
    <div id="compareAudioLog" class="log"></div>
    <div id="audioComparisonResults" style="display: none;">
      <h4>对比结果</h4>
      <div id="nativeAudioResult" class="comparison-result"></div>
      <div id="wasmAudioResult" class="comparison-result"></div>
      <div id="audioPerformanceComparison" class="performance-metrics"></div>
    </div>
    
    <h3>视频解码对比 (MP4 H.264)</h3>
    <input id="compareVideoFile" type="file" accept="video/mp4" />
    <button id="compareVideoBtn" disabled onclick="compareVideoDecoding()">开始视频解码对比</button>
    <div id="compareVideoStatus" class="status info" style="display: none;"></div>
    <div id="compareVideoLog" class="log"></div>
    <div id="videoComparisonResults" style="display: none;">
      <h4>对比结果</h4>
      <div id="nativeVideoResult" class="comparison-result"></div>
      <div id="wasmVideoResult" class="comparison-result"></div>
      <div id="videoPerformanceComparison" class="performance-metrics"></div>
    </div>
  </div>

  <script type="module" src="/src/index.js"></script>
  <script type="module">
    import { ensureFFmpeg, decodeOpusToWavBlob, decodeMp4ToWebmBlob } from '/src/ffmpeg.js';
    
    // 原生 Web API 解码功能
    class NativeAudioDecoder {
      constructor() {
        this.decoder = null;
        this.audioData = [];
        this.isDecoding = false;
      }
      
      async decodeAudioFile(file) {
        if (!('AudioDecoder' in window)) {
          throw new Error('AudioDecoder API 不支持，请使用支持 WebCodecs 的浏览器');
        }
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          
          // 创建 AudioDecoder
          this.decoder = new AudioDecoder({
            output: (audioData) => {
              this.audioData.push(audioData);
            },
            error: (error) => {
              console.error('AudioDecoder 错误:', error);
              throw error;
            }
          });
          
          // 根据文件类型配置解码器
          const config = await this.getConfigFromFile(file);
          
          await this.decoder.configure(config);
          
          // 对于 Opus 文件，需要从 Ogg 容器中提取 Opus 数据
          const opusData = this.extractOpusFromOgg(arrayBuffer);
          
          // 创建编码数据块
          const encodedChunk = new EncodedAudioChunk({
            type: 'key',
            timestamp: 0,
            data: opusData
          });
          
          this.isDecoding = true;
          this.decoder.decode(encodedChunk);
          await this.decoder.flush();
          
          // 转换为 WAV 格式
          return this.convertToWavBlob();
        } catch (error) {
          // 如果 WebCodecs 解码失败，尝试使用 Web Audio API 作为备选方案
          console.warn('WebCodecs AudioDecoder 失败，尝试使用 Web Audio API:', error.message);
          return this.decodeWithWebAudioAPI(file);
        }
      }
      
      async decodeWithWebAudioAPI(file) {
        // 使用 Web Audio API 作为备选方案
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
          
          // 转换为 WAV 格式
          return this.audioBufferToWav(audioBuffer);
        } catch (error) {
          throw new Error(`音频解码失败: ${error.message}`);
        }
      }
      
      audioBufferToWav(audioBuffer) {
        const numberOfChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const length = audioBuffer.length;
        
        // 创建 WAV 文件
        const buffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
        const view = new DataView(buffer);
        
        // WAV 头部
        const writeString = (offset, string) => {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + length * numberOfChannels * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, numberOfChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numberOfChannels * 2, true);
        view.setUint16(32, numberOfChannels * 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, length * numberOfChannels * 2, true);
        
        // 复制音频数据
        const wavData = new Int16Array(buffer, 44);
        let offset = 0;
        
        for (let i = 0; i < length; i++) {
          for (let channel = 0; channel < numberOfChannels; channel++) {
            const sample = audioBuffer.getChannelData(channel)[i];
            wavData[offset] = Math.max(-32768, Math.min(32767, sample * 32768));
            offset++;
          }
        }
        
        return new Blob([buffer], { type: 'audio/wav' });
      }
      
      async getConfigFromFile(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        
        // 只支持 Opus 格式
        if (extension === 'opus') {
          return { 
            codec: 'opus',
            sampleRate: 48000,
            numberOfChannels: 2,
            // Opus 特定的配置参数
            description: new Uint8Array([
              0x4F, 0x70, 0x75, 0x73, 0x48, 0x65, 0x61, 0x64, // "OpusHead"
              0x01, 0x02, 0x38, 0x01, 0x80, 0xBB, 0x00, 0x00, 0x00, 0x00, 0x00
            ])
          };
        }
        
        throw new Error(`不支持的音频格式: ${extension}。只支持 .opus 格式`);
      }
      
      isOpusFile(data) {
        // 检查 Ogg Opus 文件头
        return data.length >= 4 && 
               data[0] === 0x4F && data[1] === 0x67 && 
               data[2] === 0x67 && data[3] === 0x53;
      }
      
      extractOpusFromOgg(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        const opusPackets = [];
        
        let offset = 0;
        while (offset < data.length - 27) {
          // 检查 Ogg 页面头
          if (data[offset] === 0x4F && data[offset + 1] === 0x67 && 
              data[offset + 2] === 0x67 && data[offset + 3] === 0x53) {
            
            // 读取页面段数
            const pageSegments = data[offset + 26];
            const segmentTableOffset = offset + 27;
            
            // 计算页面数据大小
            let pageDataSize = 0;
            for (let i = 0; i < pageSegments; i++) {
              pageDataSize += data[segmentTableOffset + i];
            }
            
            // 提取 Opus 数据
            const pageDataOffset = segmentTableOffset + pageSegments;
            const pageData = data.slice(pageDataOffset, pageDataOffset + pageDataSize);
            
            // 检查是否是 Opus 识别头或注释头，跳过这些
            if (pageData.length > 8) {
              const headerType = pageData[0];
              if (headerType === 0x4F && pageData[1] === 0x70 && 
                  pageData[2] === 0x75 && pageData[3] === 0x73) {
                // 这是 Opus 识别头，跳过
                offset = pageDataOffset + pageDataSize;
                continue;
              }
            }
            
            // 添加 Opus 数据包
            if (pageData.length > 0) {
              opusPackets.push(pageData);
            }
            
            offset = pageDataOffset + pageDataSize;
          } else {
            offset++;
          }
        }
        
        // 合并所有 Opus 数据包
        const totalSize = opusPackets.reduce((sum, packet) => sum + packet.length, 0);
        const result = new Uint8Array(totalSize);
        let writeOffset = 0;
        
        for (const packet of opusPackets) {
          result.set(packet, writeOffset);
          writeOffset += packet.length;
        }
        
        return result.buffer;
      }
      
      
      convertToWavBlob() {
        if (this.audioData.length === 0) {
          throw new Error('没有音频数据');
        }
        
        // 简化的 WAV 转换 - 实际应用中需要更复杂的处理
        const audioData = this.audioData[0];
        const sampleRate = audioData.sampleRate;
        const numberOfChannels = audioData.numberOfChannels;
        const numberOfFrames = audioData.numberOfFrames;
        
        // 创建音频缓冲区
        const audioBuffer = audioData.copyTo();
        const audioView = new Float32Array(audioBuffer);
        
        // 转换为 16-bit PCM
        const pcmData = new Int16Array(numberOfFrames * numberOfChannels);
        for (let i = 0; i < audioView.length; i++) {
          pcmData[i] = Math.max(-32768, Math.min(32767, audioView[i] * 32768));
        }
        
        const length = pcmData.length * 2; // 16-bit = 2 bytes per sample
        const buffer = new ArrayBuffer(44 + length);
        const view = new DataView(buffer);
        
        // WAV 头部
        const writeString = (offset, string) => {
          for (let i = 0; i < string.length; i++) {
            view.setUint8(offset + i, string.charCodeAt(i));
          }
        };
        
        writeString(0, 'RIFF');
        view.setUint32(4, 36 + length, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true); // PCM format
        view.setUint16(22, numberOfChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numberOfChannels * 2, true); // byte rate
        view.setUint16(32, numberOfChannels * 2, true); // block align
        view.setUint16(34, 16, true); // bits per sample
        writeString(36, 'data');
        view.setUint32(40, length, true);
        
        // 复制 PCM 数据
        const wavView = new Int16Array(buffer, 44);
        wavView.set(pcmData);
        
        return new Blob([buffer], { type: 'audio/wav' });
      }
    }
    
    class NativeVideoDecoder {
      constructor() {
        this.decoder = null;
        this.videoFrames = [];
        this.isDecoding = false;
      }
      
      async decodeVideoFile(file) {
        if (!('VideoDecoder' in window)) {
          throw new Error('VideoDecoder API 不支持，请使用支持 WebCodecs 的浏览器');
        }
        
        try {
          const arrayBuffer = await file.arrayBuffer();
          
          // 创建 VideoDecoder
          this.decoder = new VideoDecoder({
            output: (frame) => {
              this.videoFrames.push(frame);
            },
            error: (error) => {
              console.error('VideoDecoder 错误:', error);
              throw error;
            }
          });
          
          // 配置解码器
          const config = await this.getConfigFromFile(file);
          
          await this.decoder.configure(config);
          
          // 从 MP4 文件中提取 H.264 数据
          const h264Data = this.extractH264FromMP4(arrayBuffer);
          
          // 创建编码数据
          const encodedChunk = new EncodedVideoChunk({
            type: 'key',
            timestamp: 0,
            duration: 1000000, // 1秒
            data: h264Data
          });
          
          this.isDecoding = true;
          this.decoder.decode(encodedChunk);
          await this.decoder.flush();
          
          // 转换为 WebM 格式
          return this.convertToWebmBlob();
        } catch (error) {
          // 如果 WebCodecs 解码失败，尝试使用 Canvas 作为备选方案
          console.warn('WebCodecs VideoDecoder 失败，尝试使用 Canvas 备选方案:', error.message);
          return this.decodeWithCanvas(file);
        }
      }
      
      async decodeWithCanvas(file) {
        // 使用 Canvas 作为备选方案
        const video = document.createElement('video');
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        return new Promise((resolve, reject) => {
          video.onloadedmetadata = () => {
            canvas.width = video.videoWidth;
            canvas.height = video.videoHeight;
            
            video.oncanplay = () => {
              ctx.drawImage(video, 0, 0);
              canvas.toBlob((blob) => {
                if (blob) {
                  resolve(blob);
                } else {
                  reject(new Error('Canvas 转换失败'));
                }
              }, 'video/webm');
            };
            
            video.play();
          };
          
          video.onerror = () => {
            reject(new Error('视频加载失败'));
          };
          
          video.src = URL.createObjectURL(file);
        });
      }
      
      async getConfigFromFile(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        
        // 只支持 MP4 (H.264) 格式
        if (extension === 'mp4') {
          return this.getH264Config();
        }
        
        throw new Error(`不支持的视频格式: ${extension}。只支持 .mp4 (H.264) 格式`);
      }
      
      isMP4File(data) {
        // 检查 MP4 文件头
        return data.length >= 8 && 
               data[4] === 0x66 && data[5] === 0x74 && 
               data[6] === 0x79 && data[7] === 0x70;
      }
      
      getH264Config() {
        // H.264 配置 - 针对常见的 MP4 视频
        return {
          codec: 'avc1.42E01E', // H.264 Baseline Profile, Level 3.0
          codedWidth: 1920,
          codedHeight: 1080,
          displayAspectWidth: 1920,
          displayAspectHeight: 1080,
          // 标准的 avcC (AVC Configuration) 数据
          description: new Uint8Array([
            // avcC 头部
            0x01, 0x42, 0xE0, 0x1E, // configurationVersion, AVCProfileIndication, profile_compatibility, AVCLevelIndication
            0xFF, // lengthSizeMinusOne (3)
            0xE1, // numOfSequenceParameterSets (1)
            0x00, 0x1A, // sequenceParameterSetLength (26)
            // SPS (Sequence Parameter Set)
            0x67, 0x42, 0xE0, 0x1E, 0xAB, 0x40, 0x50, 0x05, 
            0xBB, 0x01, 0x10, 0x00, 0x00, 0x03, 0x00, 0x10, 
            0x00, 0x00, 0x03, 0x03, 0xC0, 0xF1, 0x42, 0x99, 0x60,
            0x00, // numOfPictureParameterSets (0)
            // PPS (Picture Parameter Set) - 可选
            0x00, 0x00, 0x00, 0x00
          ])
        };
      }
      
      extractH264FromMP4(arrayBuffer) {
        const data = new Uint8Array(arrayBuffer);
        const h264Frames = [];
        
        // 简化的 MP4 解析，查找 H.264 数据
        let offset = 0;
        while (offset < data.length - 8) {
          // 查找 NAL 单元起始码 (0x00 0x00 0x00 0x01 或 0x00 0x00 0x01)
          if ((data[offset] === 0x00 && data[offset + 1] === 0x00 && 
               data[offset + 2] === 0x00 && data[offset + 3] === 0x01) ||
              (data[offset] === 0x00 && data[offset + 1] === 0x00 && 
               data[offset + 2] === 0x01)) {
            
            const startCodeLength = (data[offset + 2] === 0x01) ? 3 : 4;
            let frameStart = offset + startCodeLength;
            
            // 查找下一个起始码
            let frameEnd = frameStart;
            while (frameEnd < data.length - 4) {
              if ((data[frameEnd] === 0x00 && data[frameEnd + 1] === 0x00 && 
                   data[frameEnd + 2] === 0x00 && data[frameEnd + 3] === 0x01) ||
                  (data[frameEnd] === 0x00 && data[frameEnd + 1] === 0x00 && 
                   data[frameEnd + 2] === 0x01)) {
                break;
              }
              frameEnd++;
            }
            
            // 提取 H.264 帧数据
            const frameData = data.slice(frameStart, frameEnd);
            if (frameData.length > 0) {
              h264Frames.push(frameData);
            }
            
            offset = frameEnd;
          } else {
            offset++;
          }
        }
        
        // 合并所有 H.264 帧数据
        const totalSize = h264Frames.reduce((sum, frame) => sum + frame.length, 0);
        const result = new Uint8Array(totalSize);
        let writeOffset = 0;
        
        for (const frame of h264Frames) {
          result.set(frame, writeOffset);
          writeOffset += frame.length;
        }
        
        return result.buffer;
      }
      
      
      convertToWebmBlob() {
        if (this.videoFrames.length === 0) {
          throw new Error('没有视频帧数据');
        }
        
        // 这里简化处理，实际需要更复杂的 WebM 编码
        // 创建一个简单的 WebM 容器
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        const frame = this.videoFrames[0];
        
        canvas.width = frame.displayWidth;
        canvas.height = frame.displayHeight;
        ctx.drawImage(frame, 0, 0);
        
        return new Promise((resolve) => {
          canvas.toBlob(resolve, 'video/webm');
        });
      }
    }
    
    // 性能对比功能
    window.compareAudioDecoding = async function() {
      const fileInput = document.getElementById('compareAudioFile');
      const statusEl = document.getElementById('compareAudioStatus');
      const logEl = document.getElementById('compareAudioLog');
      const resultsEl = document.getElementById('audioComparisonResults');
      
      if (!fileInput.files[0]) {
        statusEl.className = 'status error';
        statusEl.textContent = '请先选择一个音频文件';
        statusEl.style.display = 'block';
        return;
      }
      
      const file = fileInput.files[0];
      const results = {
        native: null,
        wasm: null
      };
      
      try {
        statusEl.className = 'status info';
        statusEl.textContent = '正在进行音频解码对比...';
        statusEl.style.display = 'block';
        logEl.textContent = '开始音频解码性能对比...\n\n';
        
        // 测试原生 AudioDecoder
        logEl.textContent += '1. 测试原生 AudioDecoder API...\n';
        try {
          const nativeDecoder = new NativeAudioDecoder();
          const nativeStartTime = performance.now();
          const nativeBlob = await nativeDecoder.decodeAudioFile(file);
          const nativeEndTime = performance.now();
          results.native = {
            blob: nativeBlob,
            time: nativeEndTime - nativeStartTime,
            size: nativeBlob.size
          };
          logEl.textContent += `   ✓ 原生解码完成，耗时: ${results.native.time.toFixed(2)}ms\n`;
        } catch (error) {
          logEl.textContent += `   ✗ 原生解码失败: ${error.message}\n`;
          results.native = { error: error.message };
        }
        
        // 测试 WASM 解码
        logEl.textContent += '\n2. 测试 WASM (FFmpeg) 解码...\n';
        try {
          const wasmStartTime = performance.now();
          results.wasm = await decodeOpusToWavBlob(file);
          const wasmEndTime = performance.now();
          results.wasm = {
            blob: results.wasm,
            time: wasmEndTime - wasmStartTime,
            size: results.wasm.size
          };
          logEl.textContent += `   ✓ WASM解码完成，耗时: ${results.wasm.time.toFixed(2)}ms\n`;
        } catch (error) {
          logEl.textContent += `   ✗ WASM解码失败: ${error.message}\n`;
          results.wasm = { error: error.message };
        }
        
        // 显示对比结果
        displayAudioComparisonResults(results);
        resultsEl.style.display = 'block';
        
        statusEl.className = 'status success';
        statusEl.textContent = '音频解码对比完成！';
        
      } catch (error) {
        statusEl.className = 'status error';
        statusEl.textContent = '对比过程中发生错误';
        logEl.textContent += `\n对比失败: ${error.message}`;
        console.error('音频对比错误:', error);
      }
    };
    
    window.compareVideoDecoding = async function() {
      const fileInput = document.getElementById('compareVideoFile');
      const statusEl = document.getElementById('compareVideoStatus');
      const logEl = document.getElementById('compareVideoLog');
      const resultsEl = document.getElementById('videoComparisonResults');
      
      if (!fileInput.files[0]) {
        statusEl.className = 'status error';
        statusEl.textContent = '请先选择一个视频文件';
        statusEl.style.display = 'block';
        return;
      }
      
      const file = fileInput.files[0];
      const results = {
        native: null,
        wasm: null
      };
      
      try {
        statusEl.className = 'status info';
        statusEl.textContent = '正在进行视频解码对比...';
        statusEl.style.display = 'block';
        logEl.textContent = '开始视频解码性能对比...\n\n';
        
        // 测试原生 VideoDecoder
        logEl.textContent += '1. 测试原生 VideoDecoder API...\n';
        try {
          const nativeDecoder = new NativeVideoDecoder();
          const nativeStartTime = performance.now();
          const nativeBlob = await nativeDecoder.decodeVideoFile(file);
          const nativeEndTime = performance.now();
          results.native = {
            blob: nativeBlob,
            time: nativeEndTime - nativeStartTime,
            size: nativeBlob.size
          };
          logEl.textContent += `   ✓ 原生解码完成，耗时: ${results.native.time.toFixed(2)}ms\n`;
        } catch (error) {
          logEl.textContent += `   ✗ 原生解码失败: ${error.message}\n`;
          results.native = { error: error.message };
        }
        
        // 测试 WASM 解码
        logEl.textContent += '\n2. 测试 WASM (FFmpeg) 解码...\n';
        try {
          const wasmStartTime = performance.now();
          results.wasm = await decodeMp4ToWebmBlob(file);
          const wasmEndTime = performance.now();
          results.wasm = {
            blob: results.wasm,
            time: wasmEndTime - wasmStartTime,
            size: results.wasm.size
          };
          logEl.textContent += `   ✓ WASM解码完成，耗时: ${results.wasm.time.toFixed(2)}ms\n`;
        } catch (error) {
          logEl.textContent += `   ✗ WASM解码失败: ${error.message}\n`;
          results.wasm = { error: error.message };
        }
        
        // 显示对比结果
        displayVideoComparisonResults(results);
        resultsEl.style.display = 'block';
        
        statusEl.className = 'status success';
        statusEl.textContent = '视频解码对比完成！';
        
      } catch (error) {
        statusEl.className = 'status error';
        statusEl.textContent = '对比过程中发生错误';
        logEl.textContent += `\n对比失败: ${error.message}`;
        console.error('视频对比错误:', error);
      }
    };
    
    function displayAudioComparisonResults(results) {
      const nativeResultEl = document.getElementById('nativeAudioResult');
      const wasmResultEl = document.getElementById('wasmAudioResult');
      const comparisonEl = document.getElementById('audioPerformanceComparison');
      
      // 原生结果
      if (results.native && !results.native.error) {
        nativeResultEl.innerHTML = `
          <h5>原生 AudioDecoder 结果</h5>
          <p>解码时间: ${results.native.time.toFixed(2)}ms</p>
          <p>输出大小: ${results.native.size} bytes</p>
          <audio controls src="${URL.createObjectURL(results.native.blob)}"></audio>
        `;
      } else {
        nativeResultEl.innerHTML = `
          <h5>原生 AudioDecoder 结果</h5>
          <p style="color: red;">解码失败: ${results.native?.error || '未知错误'}</p>
          <p style="color: gray; font-size: 12px;">WebCodecs API 对文件格式要求严格，可能需要特定的编码参数</p>
        `;
      }
      
      // WASM结果
      if (results.wasm && !results.wasm.error) {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p>解码时间: ${results.wasm.time.toFixed(2)}ms</p>
          <p>输出大小: ${results.wasm.size} bytes</p>
          <audio controls src="${URL.createObjectURL(results.wasm.blob)}"></audio>
        `;
      } else {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p style="color: red;">解码失败: ${results.wasm?.error || '未知错误'}</p>
        `;
      }
      
      // 性能对比
      if (results.native && results.wasm && !results.native.error && !results.wasm.error) {
        const speedRatio = results.wasm.time / results.native.time;
        const fasterMethod = results.native.time < results.wasm.time ? '原生 AudioDecoder' : 'WASM (FFmpeg)';
        const speedDifference = Math.abs(results.native.time - results.wasm.time);
        const efficiency = results.native.time < results.wasm.time ? 
          `原生解码比 WASM 快 ${((results.wasm.time / results.native.time - 1) * 100).toFixed(1)}%` :
          `WASM 解码比原生快 ${((results.native.time / results.wasm.time - 1) * 100).toFixed(1)}%`;
        
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p><strong>速度对比:</strong> ${fasterMethod} 更快</p>
          <p><strong>时间差:</strong> ${speedDifference.toFixed(2)}ms</p>
          <p><strong>速度比:</strong> ${speedRatio.toFixed(2)}x</p>
          <p><strong>效率提升:</strong> ${efficiency}</p>
          <p><strong>大小对比:</strong> 原生 ${results.native.size} bytes vs WASM ${results.wasm.size} bytes</p>
        `;
      } else {
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p style="color: orange;">无法进行完整对比，部分解码失败</p>
        `;
      }
    }
    
    function displayVideoComparisonResults(results) {
      const nativeResultEl = document.getElementById('nativeVideoResult');
      const wasmResultEl = document.getElementById('wasmVideoResult');
      const comparisonEl = document.getElementById('videoPerformanceComparison');
      
      // 原生结果
      if (results.native && !results.native.error) {
        nativeResultEl.innerHTML = `
          <h5>原生 VideoDecoder 结果</h5>
          <p>解码时间: ${results.native.time.toFixed(2)}ms</p>
          <p>输出大小: ${results.native.size} bytes</p>
          <video controls src="${URL.createObjectURL(results.native.blob)}"></video>
        `;
      } else {
        nativeResultEl.innerHTML = `
          <h5>原生 VideoDecoder 结果</h5>
          <p style="color: red;">解码失败: ${results.native?.error || '未知错误'}</p>
          <p style="color: gray; font-size: 12px;">WebCodecs API 对文件格式要求严格，可能需要特定的编码参数</p>
        `;
      }
      
      // WASM结果
      if (results.wasm && !results.wasm.error) {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p>解码时间: ${results.wasm.time.toFixed(2)}ms</p>
          <p>输出大小: ${results.wasm.size} bytes</p>
          <video controls src="${URL.createObjectURL(results.wasm.blob)}"></video>
        `;
      } else {
        wasmResultEl.innerHTML = `
          <h5>WASM (FFmpeg) 结果</h5>
          <p style="color: red;">解码失败: ${results.wasm?.error || '未知错误'}</p>
        `;
      }
      
      // 性能对比
      if (results.native && results.wasm && !results.native.error && !results.wasm.error) {
        const speedRatio = results.wasm.time / results.native.time;
        const fasterMethod = results.native.time < results.wasm.time ? '原生 VideoDecoder' : 'WASM (FFmpeg)';
        const speedDifference = Math.abs(results.native.time - results.wasm.time);
        const efficiency = results.native.time < results.wasm.time ? 
          `原生解码比 WASM 快 ${((results.wasm.time / results.native.time - 1) * 100).toFixed(1)}%` :
          `WASM 解码比原生快 ${((results.native.time / results.wasm.time - 1) * 100).toFixed(1)}%`;
        
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p><strong>速度对比:</strong> ${fasterMethod} 更快</p>
          <p><strong>时间差:</strong> ${speedDifference.toFixed(2)}ms</p>
          <p><strong>速度比:</strong> ${speedRatio.toFixed(2)}x</p>
          <p><strong>效率提升:</strong> ${efficiency}</p>
          <p><strong>大小对比:</strong> 原生 ${results.native.size} bytes vs WASM ${results.wasm.size} bytes</p>
        `;
      } else {
        comparisonEl.innerHTML = `
          <h5>性能对比</h5>
          <p style="color: orange;">无法进行完整对比，部分解码失败</p>
        `;
      }
    }
    
    // 检查 Web API 支持
    function checkAPISupport() {
      const audioSupportEl = document.getElementById('audioDecoderSupport');
      const videoSupportEl = document.getElementById('videoDecoderSupport');
      
      // 检查 AudioDecoder 支持
      if ('AudioDecoder' in window) {
        audioSupportEl.className = 'api-support-check supported';
        audioSupportEl.textContent = '✓ AudioDecoder API 支持';
      } else {
        audioSupportEl.className = 'api-support-check not-supported';
        audioSupportEl.textContent = '✗ AudioDecoder API 不支持 (需要支持 WebCodecs 的浏览器)';
      }
      
      // 检查 VideoDecoder 支持
      if ('VideoDecoder' in window) {
        videoSupportEl.className = 'api-support-check supported';
        videoSupportEl.textContent = '✓ VideoDecoder API 支持';
      } else {
        videoSupportEl.className = 'api-support-check not-supported';
        videoSupportEl.textContent = '✗ VideoDecoder API 不支持 (需要支持 WebCodecs 的浏览器)';
      }
    }
    
    // 初始化事件监听器
    function initializeEventListeners() {
      // 音频文件选择
      const audioFileInput = document.getElementById('compareAudioFile');
      const audioBtn = document.getElementById('compareAudioBtn');
      
      audioFileInput.addEventListener('change', function() {
        audioBtn.disabled = !this.files[0];
      });
      
      // 视频文件选择
      const videoFileInput = document.getElementById('compareVideoFile');
      const videoBtn = document.getElementById('compareVideoBtn');
      
      videoFileInput.addEventListener('change', function() {
        videoBtn.disabled = !this.files[0];
      });
    }
    
    // 页面加载完成后初始化
    document.addEventListener('DOMContentLoaded', function() {
      checkAPISupport();
      initializeEventListeners();
    });
    
  </script>
</body>
</html>
